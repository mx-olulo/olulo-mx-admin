---
description: 자연어 기능 설명에서 기능 명세를 생성하거나 업데이트합니다.
---

## 사용자 입력

```text
$ARGUMENTS
```

입력이 비어있지 않으면 계속 진행하기 전에 **반드시** 사용자 입력을 고려해야 합니다.

## 개요

트리거 메시지에서 `/speckit.specify` 뒤에 사용자가 입력한 텍스트가 **바로** 기능 설명입니다. `$ARGUMENTS`가 아래에 문자 그대로 나타나더라도 이 대화에서 항상 사용 가능하다고 가정합니다. 사용자가 빈 명령을 제공하지 않는 한 반복하도록 요청하지 마십시오.

해당 기능 설명이 주어지면 다음을 수행합니다:

1. **브랜치에 대한 간결한 짧은 이름 생성** (2-4 단어):
   - 기능 설명을 분석하고 가장 의미 있는 키워드를 추출합니다
   - 기능의 본질을 포착하는 2-4 단어 짧은 이름을 만듭니다
   - 가능한 경우 행동-명사 형식 사용 (예: "add-user-auth", "fix-payment-bug")
   - 기술 용어 및 약어 유지 (OAuth2, API, JWT 등)
   - 간결하게 유지하되 한눈에 기능을 이해할 수 있을 만큼 설명적으로 유지
   - 예:
     - "사용자 인증을 추가하고 싶습니다" → "user-auth"
     - "API에 대한 OAuth2 통합 구현" → "oauth2-api-integration"
     - "분석을 위한 대시보드 생성" → "analytics-dashboard"
     - "결제 처리 시간 초과 버그 수정" → "fix-payment-timeout"

2. 저장소 루트에서 **짧은 이름 인수와 함께** `.specify/scripts/bash/create-new-feature.sh --json "$ARGUMENTS"` 스크립트를 실행하고 BRANCH_NAME 및 SPEC_FILE에 대한 JSON 출력을 구문 분석합니다. 모든 파일 경로는 절대 경로여야 합니다.

   **중요**:

   - 1단계에서 생성한 2-4 단어 짧은 이름으로 `.specify/scripts/bash/create-new-feature.sh --json "$ARGUMENTS"` 명령에 짧은 이름 인수를 추가합니다
   - Bash: `--short-name "your-generated-short-name"`
   - PowerShell: `-ShortName "your-generated-short-name"`
   - "I'm Groot"와 같은 인수의 작은따옴표의 경우 이스케이프 구문을 사용: 예) 'I'\''m Groot' (또는 가능하면 큰따옴표: "I'm Groot")
   - 이 스크립트는 한 번만 실행해야 합니다
   - JSON은 터미널에서 출력으로 제공됩니다 - 항상 이를 참조하여 찾고 있는 실제 내용을 가져옵니다

3. 필수 섹션을 이해하기 위해 `.specify/templates/spec-template.md`를 로드합니다.

4. 다음 실행 흐름을 따릅니다:

    1. 입력에서 사용자 설명 구문 분석
       비어 있는 경우: ERROR "기능 설명이 제공되지 않음"
    2. 설명에서 주요 개념 추출
       식별: 행위자, 행동, 데이터, 제약 조건
    3. 불명확한 측면의 경우:
       - 컨텍스트 및 업계 표준을 기반으로 정보에 입각한 추측을 합니다
       - 다음과 같은 경우에만 [NEEDS CLARIFICATION: 구체적인 질문]으로 표시:
         - 선택이 기능 범위 또는 사용자 경험에 상당한 영향을 미침
         - 서로 다른 의미를 가진 여러 합리적인 해석이 존재함
         - 합리적인 기본값이 없음
       - **제한: 최대 3개의 [NEEDS CLARIFICATION] 마커**
       - 영향별로 명확화 우선순위 지정: 범위 > 보안/개인정보 > 사용자 경험 > 기술 세부사항
    4. 사용자 시나리오 및 테스트 섹션 채우기
       명확한 사용자 흐름이 없는 경우: ERROR "사용자 시나리오를 결정할 수 없음"
    5. 기능 요구사항 생성
       각 요구사항은 테스트 가능해야 함
       지정되지 않은 세부 사항에 합리적인 기본값 사용 (가정 섹션에 가정 문서화)
    6. 성공 기준 정의
       측정 가능하고 기술 독립적인 결과 생성
       정량적 메트릭 (시간, 성능, 볼륨) 및 정성적 측정 (사용자 만족도, 작업 완료) 모두 포함
       각 기준은 구현 세부 사항 없이 검증 가능해야 함
    7. 주요 엔티티 식별 (데이터가 관련된 경우)
    8. 반환: SUCCESS (명세가 계획 준비됨)

5. 템플릿 구조를 사용하여 SPEC_FILE에 명세를 작성하고, 섹션 순서 및 제목을 유지하면서 기능 설명 (인수)에서 파생된 구체적인 세부 사항으로 자리 표시자를 바꿉니다.

6. **명세 품질 검증**: 초기 명세를 작성한 후 품질 기준에 대해 검증합니다:

   a. **명세 품질 체크리스트 생성**: 체크리스트 템플릿 구조를 사용하여 다음 검증 항목으로 `FEATURE_DIR/checklists/requirements.md`에 체크리스트 파일을 생성합니다:

      # 명세 품질 체크리스트: [FEATURE NAME]

      **목적**: 계획으로 진행하기 전에 명세 완전성 및 품질 검증
      **생성일**: [DATE]
      **기능**: [spec.md 링크]

      ## 내용 품질

      - [ ] 구현 세부 사항 없음 (언어, 프레임워크, API)
      - [ ] 사용자 가치 및 비즈니스 요구에 집중
      - [ ] 비기술 이해관계자를 위해 작성됨
      - [ ] 모든 필수 섹션 완료

      ## 요구사항 완전성

      - [ ] [NEEDS CLARIFICATION] 마커가 남아 있지 않음
      - [ ] 요구사항이 테스트 가능하고 모호하지 않음
      - [ ] 성공 기준이 측정 가능함
      - [ ] 성공 기준이 기술 독립적임 (구현 세부 사항 없음)
      - [ ] 모든 수락 시나리오가 정의됨
      - [ ] 엣지 케이스가 식별됨
      - [ ] 범위가 명확하게 경계 지어짐
      - [ ] 종속성 및 가정이 식별됨

      ## 기능 준비

      - [ ] 모든 기능 요구사항에 명확한 수락 기준이 있음
      - [ ] 사용자 시나리오가 주요 흐름을 다룸
      - [ ] 기능이 성공 기준에 정의된 측정 가능한 결과를 충족함
      - [ ] 구현 세부 사항이 명세로 누출되지 않음

      ## 비고

      - 미완료로 표시된 항목은 `/speckit.clarify` 또는 `/speckit.plan` 전에 명세 업데이트가 필요함

   b. **검증 확인 실행**: 각 체크리스트 항목에 대해 명세를 검토:
      - 각 항목에 대해 통과 또는 실패를 결정합니다
      - 발견된 특정 문제를 문서화합니다 (관련 명세 섹션 인용)

   c. **검증 결과 처리**:

      - **모든 항목이 통과하는 경우**: 체크리스트를 완료로 표시하고 6단계로 진행

      - **항목이 실패하는 경우 ([NEEDS CLARIFICATION] 제외)**:
        1. 실패한 항목 및 특정 문제 나열
        2. 각 문제를 해결하기 위해 명세 업데이트
        3. 모든 항목이 통과할 때까지 검증을 다시 실행합니다 (최대 3회 반복)
        4. 3회 반복 후에도 여전히 실패하는 경우 체크리스트 비고에 남은 문제를 문서화하고 사용자에게 경고

      - **[NEEDS CLARIFICATION] 마커가 남아 있는 경우**:
        1. 명세에서 모든 [NEEDS CLARIFICATION: ...] 마커 추출
        2. **제한 확인**: 3개 이상의 마커가 있는 경우 가장 중요한 3개만 유지 (범위/보안/UX 영향별) 나머지는 정보에 입각한 추측을 합니다
        3. 필요한 각 명확화 (최대 3개)에 대해 다음 형식으로 사용자에게 옵션을 제시합니다:

           ## 질문 [N]: [주제]

           **컨텍스트**: [관련 명세 섹션 인용]

           **알아야 할 사항**: [NEEDS CLARIFICATION 마커의 구체적인 질문]

           **제안된 답변**:

           | 옵션 | 답변 | 영향 |
           |--------|--------|--------------|
           | A      | [첫 번째 제안 답변] | [기능에 대한 의미] |
           | B      | [두 번째 제안 답변] | [기능에 대한 의미] |
           | C      | [세 번째 제안 답변] | [기능에 대한 의미] |
           | 사용자 정의 | 자신의 답변 제공 | [사용자 정의 입력을 제공하는 방법 설명] |

           **귀하의 선택**: _[사용자 응답 대기]_

        4. **중요 - 표 서식**: 마크다운 표가 올바르게 서식이 지정되었는지 확인:
           - 파이프가 정렬된 일관된 간격 사용
           - 각 셀은 내용 주위에 공백이 있어야 함: `| Content |` not `|Content|`
           - 헤더 구분자는 최소 3개의 대시가 있어야 함: `|--------|`
           - 표가 마크다운 미리보기에서 올바르게 렌더링되는지 테스트
        5. 질문을 순차적으로 번호 매기기 (Q1, Q2, Q3 - 최대 3개)
        6. 응답을 기다리기 전에 모든 질문을 함께 제시
        7. 사용자가 모든 질문에 대한 선택으로 응답할 때까지 기다립니다 (예: "Q1: A, Q2: 사용자 정의 - [세부 사항], Q3: B")
        8. 사용자가 선택하거나 제공한 답변으로 각 [NEEDS CLARIFICATION] 마커를 교체하여 명세를 업데이트합니다
        9. 모든 명확화가 해결된 후 검증을 다시 실행합니다

   d. **체크리스트 업데이트**: 각 검증 반복 후 현재 통과/실패 상태로 체크리스트 파일을 업데이트합니다

7. 브랜치 이름, 명세 파일 경로, 체크리스트 결과 및 다음 단계 (`/speckit.clarify` 또는 `/speckit.plan`)에 대한 준비 상태와 함께 완료를 보고합니다.

**참고:** 스크립트는 새 브랜치를 생성 및 체크아웃하고 명세 파일을 작성하기 전에 초기화합니다.

## 일반 지침

## 빠른 지침

- 사용자가 필요한 **무엇**과 **왜**에 집중합니다.
- 구현 방법 피하기 (기술 스택, API, 코드 구조 없음).
- 개발자가 아닌 비즈니스 이해관계자를 위해 작성됨.
- 명세에 포함된 체크리스트를 생성하지 마십시오. 별도의 명령이 될 것입니다.

### 섹션 요구사항

- **필수 섹션**: 모든 기능에 대해 완료해야 함
- **선택적 섹션**: 기능과 관련이 있을 때만 포함
- 섹션이 적용되지 않는 경우 완전히 제거 ("N/A"로 남겨두지 마십시오)

### AI 생성용

사용자 프롬프트에서 이 명세를 만들 때:

1. **정보에 입각한 추측**: 컨텍스트, 업계 표준 및 일반적인 패턴을 사용하여 갭을 채웁니다
2. **가정 문서화**: 가정 섹션에 합리적인 기본값을 기록합니다
3. **명확화 제한**: 최대 3개의 [NEEDS CLARIFICATION] 마커 - 다음과 같은 중요한 결정에만 사용:
   - 기능 범위 또는 사용자 경험에 상당한 영향을 미침
   - 서로 다른 의미를 가진 여러 합리적인 해석이 있음
   - 합리적인 기본값이 없음
4. **명확화 우선순위 지정**: 범위 > 보안/개인정보 > 사용자 경험 > 기술 세부사항
5. **테스터처럼 생각**: 모든 모호한 요구사항은 "테스트 가능하고 모호하지 않은" 체크리스트 항목에 실패해야 합니다
6. **명확화가 필요한 일반적인 영역** (합리적인 기본값이 없는 경우에만):
   - 기능 범위 및 경계 (특정 사용 사례 포함/제외)
   - 사용자 유형 및 권한 (여러 상충되는 해석이 가능한 경우)
   - 보안/규정 준수 요구사항 (법적/재정적으로 중요한 경우)

**합리적인 기본값의 예** (이것에 대해 질문하지 마십시오):

- 데이터 보존: 도메인에 대한 업계 표준 관행
- 성능 목표: 지정되지 않은 한 표준 웹/모바일 앱 기대
- 오류 처리: 적절한 폴백이 있는 사용자 친화적인 메시지
- 인증 방법: 웹 앱의 경우 표준 세션 기반 또는 OAuth2
- 통합 패턴: 달리 지정되지 않는 한 RESTful API

### 성공 기준 지침

성공 기준은 다음과 같아야 합니다:

1. **측정 가능**: 특정 메트릭 포함 (시간, 백분율, 개수, 비율)
2. **기술 독립적**: 프레임워크, 언어, 데이터베이스 또는 도구 언급 없음
3. **사용자 중심**: 시스템 내부가 아닌 사용자/비즈니스 관점에서 결과 설명
4. **검증 가능**: 구현 세부 사항을 알지 못해도 테스트/검증 가능

**좋은 예**:

- "사용자가 3분 이내에 체크아웃을 완료할 수 있음"
- "시스템이 10,000명의 동시 사용자를 지원함"
- "검색의 95%가 1초 이내에 결과를 반환함"
- "작업 완료율이 40% 향상됨"

**나쁜 예** (구현 중심):

- "API 응답 시간이 200ms 이하임" (너무 기술적, "사용자가 즉시 결과를 봄" 사용)
- "데이터베이스가 1000 TPS를 처리할 수 있음" (구현 세부 사항, 사용자 대면 메트릭 사용)
- "React 구성 요소가 효율적으로 렌더링됨" (프레임워크별)
- "Redis 캐시 적중률이 80% 이상" (기술별)

## 사고 및 응답
반드시 모든 흐름의 출력과 응답, 사고는 우리말(한글)로 진행하시오.
