---
description: 최대 5개의 고도로 타겟팅된 명확화 질문을 통해 현재 기능 명세의 미명시 영역을 식별하고 답변을 명세에 다시 인코딩합니다.
---

## 사용자 입력

```text
$ARGUMENTS
```

입력이 비어있지 않으면 계속 진행하기 전에 **반드시** 사용자 입력을 고려해야 합니다.

## 개요

목표: 활성 기능 명세에서 모호성 또는 누락된 의사 결정 지점을 감지하고 줄이며 명확화를 명세 파일에 직접 기록합니다.

참고: 이 명확화 워크플로는 `/speckit.plan` 호출 **전에** 실행 (및 완료)될 것으로 예상됩니다. 사용자가 명확화를 건너뛴다고 명시적으로 진술하는 경우 (예: 탐색적 스파이크), 진행할 수 있지만 다운스트림 재작업 위험이 증가한다고 경고해야 합니다.

실행 단계:

1. 저장소 루트에서 `.specify/scripts/bash/check-prerequisites.sh --json --paths-only`를 **한 번** 실행합니다 (결합된 `--json --paths-only` 모드 / `-Json -PathsOnly`). 최소 JSON 페이로드 필드를 구문 분석합니다:
   - `FEATURE_DIR`
   - `FEATURE_SPEC`
   - (향후 연결된 흐름을 위해 선택적으로 `IMPL_PLAN`, `TASKS` 캡처.)
   - JSON 구문 분석이 실패하면 중단하고 사용자에게 `/speckit.specify`를 다시 실행하거나 기능 브랜치 환경을 확인하도록 지시합니다.
   - "I'm Groot"와 같은 인수의 작은따옴표의 경우 이스케이프 구문을 사용: 예) 'I'\''m Groot' (또는 가능하면 큰따옴표: "I'm Groot").

2. 현재 명세 파일을 로드합니다. 이 분류법을 사용하여 구조화된 모호성 및 커버리지 스캔을 수행합니다. 각 카테고리에 대해 상태를 표시: 명확함 / 부분 / 누락. 우선순위 지정에 사용되는 내부 커버리지 맵을 생성합니다 (질문이 없으면 원시 맵을 출력하지 마십시오).

   기능 범위 및 동작:
   - 핵심 사용자 목표 및 성공 기준
   - 명시적 범위 외 선언
   - 사용자 역할 / 페르소나 차별화

   도메인 및 데이터 모델:
   - 엔티티, 속성, 관계
   - 식별 및 고유성 규칙
   - 라이프사이클/상태 전환
   - 데이터 볼륨 / 규모 가정

   상호 작용 및 UX 흐름:
   - 중요한 사용자 여정 / 시퀀스
   - 오류/비어있음/로딩 상태
   - 접근성 또는 현지화 참고 사항

   비기능 품질 속성:
   - 성능 (지연 시간, 처리량 목표)
   - 확장성 (수평/수직, 제한)
   - 신뢰성 및 가용성 (가동 시간, 복구 기대)
   - 관찰 가능성 (로깅, 메트릭, 추적 신호)
   - 보안 및 개인 정보 보호 (인증/인가, 데이터 보호, 위협 가정)
   - 규정 준수 / 규제 제약 (있는 경우)

   통합 및 외부 종속성:
   - 외부 서비스/API 및 실패 모드
   - 데이터 가져오기/내보내기 형식
   - 프로토콜/버전 관리 가정

   엣지 케이스 및 실패 처리:
   - 부정적인 시나리오
   - 속도 제한 / 조절
   - 충돌 해결 (예: 동시 편집)

   제약 및 트레이드오프:
   - 기술 제약 (언어, 저장소, 호스팅)
   - 명시적 트레이드오프 또는 거부된 대안

   용어 및 일관성:
   - 표준 용어집 용어
   - 피해야 할 동의어 / 사용 중지된 용어

   완료 신호:
   - 수락 기준 테스트 가능성
   - 측정 가능한 완료 정의 스타일 지표

   기타 / 자리 표시자:
   - TODO 마커 / 미해결 결정
   - 정량화가 부족한 모호한 형용사 ("견고한", "직관적인")

   부분 또는 누락 상태의 각 카테고리에 대해 다음과 같은 경우를 제외하고 후보 질문 기회를 추가합니다:
   - 명확화가 구현 또는 검증 전략을 실질적으로 변경하지 않음
   - 정보가 계획 단계로 연기하는 것이 더 나음 (내부적으로 기록)

3. 후보 명확화 질문의 우선순위 대기열을 (내부적으로) 생성합니다 (최대 5개). 한 번에 모두 출력하지 마십시오. 다음 제약 조건을 적용합니다:
    - 전체 세션에서 최대 10개의 총 질문.
    - 각 질문은 다음 중 하나로 답변 가능해야 합니다:
       * 짧은 객관식 선택 (2–5개의 고유하고 상호 배타적인 옵션), 또는
       * 한 단어 / 짧은 구문 답변 (명시적으로 제한: "<=5 단어로 답변").
   - 아키텍처, 데이터 모델링, 작업 분해, 테스트 설계, UX 동작, 운영 준비 또는 규정 준수 검증에 실질적으로 영향을 미치는 답변이 있는 질문만 포함합니다.
   - 카테고리 커버리지 균형 보장: 최고 영향의 미해결 카테고리를 먼저 다루도록 시도; 단일 고영향 영역 (예: 보안 태세)이 미해결될 때 두 개의 저영향 질문을 하지 마십시오.
   - 이미 답변된 질문, 사소한 스타일 선호 또는 계획 수준 실행 세부 사항 (정확성을 차단하지 않는 한) 제외합니다.
   - 다운스트림 재작업 위험을 줄이거나 잘못 정렬된 수락 테스트를 방지하는 명확화를 선호합니다.
   - 5개 이상의 카테고리가 미해결 상태로 남아 있는 경우 (영향 * 불확실성) 휴리스틱으로 상위 5개를 선택합니다.

4. 순차 질문 루프 (대화형):
    - 한 번에 **정확히 하나**의 질문을 제시합니다.
    - 객관식 질문의 경우:
       * **모든 옵션을 분석**하고 다음을 기반으로 **가장 적합한 옵션**을 결정합니다:
          - 프로젝트 유형에 대한 모범 사례
          - 유사한 구현의 일반적인 패턴
          - 위험 감소 (보안, 성능, 유지 관리)
          - 명세에서 볼 수 있는 명시적 프로젝트 목표 또는 제약 조건과의 정렬
       * **권장 옵션을 맨 위에 명확한 근거와 함께 눈에 띄게** 제시합니다 (이것이 최선의 선택인 이유를 설명하는 1-2 문장).
       * 형식: `**권장:** 옵션 [X] - <근거>`
       * 그런 다음 모든 옵션을 마크다운 표로 렌더링합니다:

       | 옵션 | 설명 |
       |--------|-------------|
       | A | <옵션 A 설명> |
       | B | <옵션 B 설명> |
       | C | <옵션 C 설명> | (필요에 따라 D/E 추가, 최대 5개)
       | 짧게 | 다른 짧은 답변 제공 (<=5 단어) | (자유 형식 대안이 적절한 경우에만 포함)

       * 표 다음에 추가: `옵션 문자 (예: "A")로 답변하거나, "예" 또는 "권장"이라고 말하여 권장 사항을 수락하거나, 자신의 짧은 답변을 제공할 수 있습니다.`
    - 짧은 답변 스타일의 경우 (의미 있는 개별 옵션 없음):
       * 모범 사례와 컨텍스트를 기반으로 **제안된 답변**을 제공합니다.
       * 형식: `**제안:** <제안된 답변> - <간단한 근거>`
       * 그런 다음 출력: `형식: 짧은 답변 (<=5 단어). "예" 또는 "제안"이라고 말하여 제안을 수락하거나 자신의 답변을 제공할 수 있습니다.`
    - 사용자가 답변한 후:
       * 사용자가 "예", "권장" 또는 "제안"으로 답변하면 이전에 진술한 권장 사항/제안을 답변으로 사용합니다.
       * 그렇지 않으면 답변이 하나의 옵션에 매핑되거나 <=5 단어 제약 조건에 맞는지 확인합니다.
       * 모호한 경우 빠른 명확화를 요청합니다 (카운트는 여전히 동일한 질문에 속함; 진행하지 마십시오).
       * 만족스러우면 작업 메모리에 기록하고 (아직 디스크에 쓰지 마십시오) 다음 대기 중인 질문으로 이동합니다.
    - 다음과 같은 경우 추가 질문 중지:
       * 모든 중요한 모호성이 조기에 해결됨 (나머지 대기 항목이 불필요해짐), 또는
       * 사용자가 완료 신호를 보냄 ("완료", "좋음", "더 이상 없음"), 또는
       * 5개의 질문에 도달함.
    - 미래의 대기 중인 질문을 미리 공개하지 마십시오.
    - 시작 시 유효한 질문이 없으면 즉시 중요한 모호성이 없다고 보고합니다.

5. 각 수락된 답변 후 통합 (점진적 업데이트 접근):
    - 명세의 메모리 내 표현 (시작 시 한 번 로드) + 원시 파일 내용을 유지합니다.
    - 이 세션에서 첫 번째 통합 답변의 경우:
       * `## Clarifications` 섹션이 존재하는지 확인합니다 (누락된 경우 명세 템플릿에 따라 최상위 컨텍스트/개요 섹션 바로 다음에 생성).
       * 그 아래에 오늘 날짜에 대한 `### Session YYYY-MM-DD` 부제목을 생성합니다 (없는 경우).
    - 수락 직후 불릿 라인을 추가합니다: `- Q: <질문> → A: <최종 답변>`.
    - 그런 다음 즉시 가장 적절한 섹션에 명확화를 적용합니다:
       * 기능 모호성 → 기능 요구사항의 불릿을 업데이트하거나 추가합니다.
       * 사용자 상호 작용 / 행위자 구별 → 명확화된 역할, 제약 또는 시나리오로 사용자 스토리 또는 행위자 하위 섹션 (있는 경우) 업데이트.
       * 데이터 형태 / 엔티티 → 데이터 모델 업데이트 (필드, 유형, 관계 추가) 순서 유지; 추가된 제약 조건을 간결하게 기록.
       * 비기능 제약 → 비기능 / 품질 속성 섹션에서 측정 가능한 기준 추가/수정 (모호한 형용사를 메트릭 또는 명시적 목표로 변환).
       * 엣지 케이스 / 부정적 흐름 → 엣지 케이스 / 오류 처리 아래에 새 불릿 추가 (또는 템플릿이 자리 표시자를 제공하는 경우 해당 하위 섹션 생성).
       * 용어 충돌 → 명세 전체에서 용어 정규화; 필요한 경우 `(이전에 "X"로 지칭됨)` 한 번 추가하여 원본만 유지.
    - 명확화가 이전의 모호한 진술을 무효화하는 경우 중복하는 대신 해당 진술을 교체합니다; 쓸모없고 모순되는 텍스트를 남기지 마십시오.
    - 컨텍스트 손실 위험을 최소화하기 위해 각 통합 **후** 명세 파일을 저장합니다 (원자적 덮어쓰기).
    - 서식 유지: 관련 없는 섹션을 재정렬하지 마십시오; 제목 계층을 그대로 유지합니다.
    - 삽입된 각 명확화를 최소화하고 테스트 가능하게 유지합니다 (서술적 드리프트 방지).

6. 검증 (각 쓰기 + 최종 패스 후 수행):
   - 명확화 세션에는 수락된 답변당 정확히 하나의 불릿이 포함됩니다 (중복 없음).
   - 총 질문 (수락됨) ≤ 5.
   - 업데이트된 섹션에는 새 답변이 해결해야 할 모호한 자리 표시자가 남아 있지 않습니다.
   - 이제 유효하지 않은 모순되는 이전 진술이 남아 있지 않습니다 (제거된 이제 유효하지 않은 대체 선택 스캔).
   - 마크다운 구조 유효; 허용된 새 제목만: `## Clarifications`, `### Session YYYY-MM-DD`.
   - 용어 일관성: 업데이트된 모든 섹션에서 동일한 표준 용어 사용.

7. 업데이트된 명세를 `FEATURE_SPEC`에 다시 씁니다.

8. 완료 보고 (질문 루프가 끝나거나 조기 종료 후):
   - 질문하고 답변한 수.
   - 업데이트된 명세 경로.
   - 수정된 섹션 (이름 나열).
   - 각 분류 카테고리를 상태와 함께 나열하는 커버리지 요약 표: 해결됨 (부분/누락이었고 해결됨), 연기됨 (질문 할당량을 초과하거나 계획에 더 적합), 명확함 (이미 충분), 미해결 (여전히 부분/누락이지만 낮은 영향).
   - 미해결 또는 연기가 남아 있는 경우 `/speckit.plan`으로 진행할지 또는 계획 후 나중에 `/speckit.clarify`를 다시 실행할지 권장합니다.
   - 제안된 다음 명령.

동작 규칙:
- 의미 있는 모호성이 발견되지 않은 경우 (또는 모든 잠재적 질문이 낮은 영향일 경우), 응답: "공식 명확화가 필요한 중요한 모호성이 감지되지 않았습니다." 그리고 진행을 제안합니다.
- 명세 파일이 누락된 경우 사용자에게 먼저 `/speckit.specify`를 실행하도록 지시합니다 (여기서 새 명세를 만들지 마십시오).
- 총 5개 이상의 질문을 초과하지 마십시오 (단일 질문에 대한 명확화 재시도는 새 질문으로 계산되지 않음).
- 부재가 기능 명확성을 차단하지 않는 한 추측적인 기술 스택 질문을 피합니다.
- 사용자 조기 종료 신호 존중 ("중지", "완료", "진행").
 - 전체 커버리지로 인해 질문이 없는 경우 간결한 커버리지 요약 (모든 카테고리 명확함)을 출력한 다음 진행을 제안합니다.
 - 미해결된 고영향 카테고리가 남아 있는 상태에서 할당량에 도달한 경우 근거와 함께 연기 아래에 명시적으로 플래그를 지정합니다.

우선순위 지정을 위한 컨텍스트: $ARGUMENTS

## 사고 및 응답
반드시 모든 흐름의 출력과 응답, 사고는 우리말(한글)로 진행하시오.
